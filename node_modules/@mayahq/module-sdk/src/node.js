const os = require('os')
const path = require("path");
const GlobalStorage = require("./storage/globalStorage");
const NodeStorage = require("./storage/nodeStorage");
const RuntimeStorage = require("./storage/runtimeStorage");
const Tokens = require("./tokens");

class Node {
	constructor(
		node,
		RED,
		opts = {
			packageName: "",
		}
	) {
		this.redNode = node;
		this._node = node;
		this.RED = RED;

		const nodeRedDir = this.RED.settings.get("userDir");
		this.profileSlug = this.RED.settings.get('profileSlug') || 'none'

		if (process.env.RUNTIME_ID) {
			this._mayaRuntimeId = process.env.RUNTIME_ID
		} else {
			const relativeUserDir = path.basename(this.RED.settings.get("userDir"));
			const elems = relativeUserDir.split("_");
			if (elems.length < 2) {
				const e = new Error(
					'The node-red directory name must be of the format ".nodered_XXXXX"'
				);
				e.type = "INVALID_USERDIR_FORMAT";
				throw e;
			}
	
			this._mayaRuntimeId = elems[elems.length - 1];
		}
		
		const root = path.join(nodeRedDir, "..", "..");
		if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
			this.mayaRoot = path.join(os.homedir(), 'mayaRoot')
		} else {
			this.mayaRoot = root;
		}

		this.storage = {
			node: new NodeStorage({
				root,
				nodeId: this._node.id,
				runtimeId: this._mayaRuntimeId,
			}),
			runtime: new RuntimeStorage({
				root,
				runtimeId: this._mayaRuntimeId,
			}),
			global: new GlobalStorage({
				root,
			}),
		};

		this.masterKey = this.RED.settings.get("masterKey") || opts.masterKey;
		if (process.env.RUNTIME_BACKEND_BASEURL) {
			this.mayaBackendUrl = process.env.RUNTIME_BACKEND_BASEURL
		} else {
			this.mayaBackendUrl =
				this.RED.settings.get("mayaBackendUrl") ||
				"https://backend.prod.mayalabs.io";
		}
		
		const masterKeyRequired = (process.env.RUNTIME_PLATFORM !== 'CLOUD' && process.env.NODE_ENV !== 'development')
		if (!this.masterKey && masterKeyRequired) {
			throw new Error(
				`Unable to get masterKey. If you're a developer, pass the masterKey in the constructor opts.`
			);
		}
		this.modulePackageName = opts.packageName;

		// Deal with tokens
		this.tokens = new Tokens(this);
		try {
			this.tokens.get().then((vals) => {
				try {
					console.log('Got token vals', vals.tokens)
					this.tokens.vals = vals.tokens
				} catch (e) {
					console.log('Null token vals')
				}
			});
		} catch (e) {
			console.log('Token fetch failed')
		}
	}

	static isNode = true;

	// Override with schema of class
	static schema = null;

	// Override this
	onInit() {
		return;
	}

	// Override this
	async onMessage(msg, vals) {
		return;
	}

	static generateHTML(docsPath) {
		return this.schema.generateHTML(docsPath);
	}

	setStatus(status, message) {
		switch (status) {
			case "SUCCESS": {
				this._node.status({
					fill: "green",
					shape: "dot",
					text: message,
				});
				break;
			}
			case "PROGRESS": {
				this._node.status({
					fill: "yellow",
					shape: "dot",
					text: message,
				});
				break;
			}
			case "ERROR": {
				this._node.status({
					fill: "red",
					shape: "ring",
					text: message,
				});
				break;
			}
			default:
				return;
		}
	}

	send(msg) {
		this._node.send(msg);
	}

	config(RED, config) {
		this._config = config;
		const schema = this.constructor.schema;

		try {
			Object.entries(schema.fields).forEach(([name, field]) => {
				field.registerWithNode(name, this._node, config);
			});
		} catch (e) {
			console.log(e);
			this._node.warn("error resolving valuable", this.constructor.schema);
		}

		// Get all credentials from related config nodes
		const credentials = {};
		Object.entries(schema.fields).forEach(([name, field]) => {
			if (!field.isConfigNodeField) {
				return;
			}

			const { creds } = field.resolveValue(RED, name, this._node, config, null);
			credentials[name] = creds;
		});

		if (schema.isConfig) {
			credentials._self = RED.nodes.getCredentials(this._node.id);
		}
		this.credentials = credentials;

		this.onInit(RED);

		// Register the input handler
		this._node.on("input", async (msg) => {
			// If the message has the error property set, forward it right away.
			try {
				if (msg.__isError === true) {
					this._node.send(msg);
					return;
				}

				const vals = {};
				Object.entries(schema.fields).forEach(([name, field]) => {
					if (field.isConfigNodeField) {
						vals[name] = field.resolveValue(
							RED,
							name,
							this._node,
							config,
							msg
						).node;
						return;
					}

					vals[name] = field.resolveValue(RED, name, this._node, config, msg);
				});

				const newmsg = await this.onMessage(msg, vals);
				if (newmsg) {
					this._node.send(newmsg);
				}
			} catch (e) {
				console.log("[module-sdk]: Node had an unhandled error:", e);
				this.setStatus("ERROR", `[module-sdk]: ${e.message}`);
				this._node.send({
					...msg,
					__isError: true,
					__error: e,
				});
			}
		});
	}
}

module.exports = Node;
