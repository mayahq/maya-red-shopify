const { localDb, httpAdapter } = require("@mayahq/maya-db");
const path = require('path')
const axios = require('axios')

const SECOND = 1000
const MINUTE = 60 * SECOND
const MAYA_DEV_FOLDER = '.mayadev'



class Tokens {
    constructor(node) {
        this.node = node
        this.db = localDb({
            root: path.join(node.mayaRoot, 'db'),
            encryptionKey: node.masterKey
        })

        this.dbApiUrl = `${node.mayaBackendUrl}/api/v2/mayadb/db-operation`

        this.mayaJWT = null
        this.mayaJWTLastRefreshed = null
        const encryptionType = (process.env.NODE_ENV === 'development' || process.env.RUNTIME_PLATFORM === 'CLOUD') ? 'BLOCK' : 'ENCRYPTED_BLOCK'

        this.hierarchy = {
            tokens: [{
                modules: [{
                    [node.modulePackageName]: encryptionType
                }],
                runtimeMappings: [{
                    [node._mayaRuntimeId]: encryptionType
                }],
                mayaTokens: [{
                    JWT: encryptionType
                }]
            }]
        }

        if (!node.mayaRoot.includes(MAYA_DEV_FOLDER)) {
            this.db.ensureHierarchy(this.hierarchy)
        }


        this.vals = {
            access_token: null,
            refresh_token: null,
            lastUpdated: null,
            resource: null
        }
    }

    async validateHierarchy() {
        this.db.ensureHierarchy(this.hierarchy)
    }


    async lockLocalTokens(callback) {
        const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)
        await this.validateHierarchy(this.hierarchy)
        const result = await tokenBlock.acquireLock(async () => {
            const localToks = await this.getLocal({ lock: false })
            if (localToks === null) {
                return await callback({
                    access_token: null,
                    refresh_token: null,
                    lastUpdated: null
                })
            }
            return await callback({ ...localToks })
        })

        return result
    }

    async getLocal({ lock = true, referenceId = null } = {}) {
        try {
            await this.validateHierarchy(this.hierarchy)

            const runtimeBlock = this.db.collection('tokens/runtimeMappings').block(this.node._mayaRuntimeId)
            const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)
            
            const func = lock ? 'lockAndGet' : 'get'
            
            // Try getting referenceId from vals if it was set earlier
            if (referenceId === null) {
                referenceId = this.vals.referenceId
            }

            // Otherwise try getting it from the local store
            if (!referenceId) {
                const profileResult = await runtimeBlock[func]({
                    [this.node.modulePackageName]: null
                })
                
                referenceId = profileResult[this.node.modulePackageName]
                console.log('profileResult', profileResult)
                if (!referenceId || typeof referenceId !== 'string') {
                    console.log('Invalid result while fetching token:', referenceId)
                    return null
                }
            }

            const tokFileResult = await tokenBlock[func]({
                profiles: {
                    [referenceId]: null
                }
            })

            return {
                ...tokFileResult.profiles[referenceId],
                referenceId
            }
        } catch (e) {
            console.log('Error getting local tokens', e)
            return null
        }
    }

    async get({ lock = true, cacheLimit = 45 * MINUTE } = {}) {
        console.log('get called')
        try {
            await this.validateHierarchy(this.hierarchy)
            const localToks = await this.getLocal({ lock })
            if (localToks !== null && Date.now() - localToks.lastUpdated < cacheLimit) {
                console.log(`Get: cache hit. Tokens were ${(Date.now() - localToks.lastUpdated)/(60*1000)} minutes old`)
                return localToks
            }

            let authHeaders = {}
            if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
                authHeaders = {
                    'maya-api-key': await this.getApiKey()
                }
            } else {
                const { accessToken, refreshToken } = await this.getMayaBackendToken()
                authHeaders = {
                    Authorization: `Bearer ${accessToken}`,
                    maya_refresh_token: refreshToken
                }
            }

            const request = {
                method: 'POST',
                url: `${this.node.mayaBackendUrl}/api/v2/oauth/gettokens`,
                headers: {
                    ...authHeaders
                },
                data: {
                    runtimeId: this.node._mayaRuntimeId,
                    moduleId: this.node.modulePackageName,
                    lock: lock,
                    leaveLock: false,
                    strict: false,
                    backupTokVals: localToks
                }
            }
            
            const res = await axios(request)
            // console.log('remoteToks', res.data)
            this.resetMayaTokenIfRequired(res)
            const { tokens } = res.data
            try {
                const { referenceId } = localToks
                await this.setLocal(tokens, { lock, referenceId })
                console.log('Saved to local cache', lock, referenceId)
            } catch (e) {
                console.log('Get: Failed to set tokens in local cache:', e)
            }
            return tokens
        } catch (e) {
            console.log('Error fetching tokens', e)
            return null
        }
    }

    async getMayaBackendToken() {
        await this.validateHierarchy(this.hierarchy)
        
        const getFromDb = (
            this.mayaJWT === null ||
            this.mayaJWTLastRefreshed === null ||
            Date.now() - this.mayaJWTLastRefreshed > 30 * MINUTE - 1
        )

        const jwtBlock = this.db.block('tokens/mayaTokens/JWT')
        const { JWT, accessToken, refreshToken } = await jwtBlock.lockAndGet({
            JWT: null,
            accessToken: null,
            refreshToken: null
        })

        // console.log('backend tokens:', {JWT, accessToken, refreshToken})

        if (getFromDb) {
            this.mayaJWT = JWT || accessToken
            this.mayaJWTLastRefreshed = Date.now() // Just setting this to make things easier to reason about
            return { accessToken, refreshToken }
        } else {
            return { accessToken: this.mayaJWT, refreshToken }
        }
    }

    async getApiKey() {
        return process.env.MAYA_API_KEY
    }

    async refresh({ access_token, refresh_token }) {
        let authHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            authHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken, refreshToken } = await this.getMayaBackendToken()
            authHeaders = {
                Authorization: `Bearer ${accessToken}`,
                maya_refresh_token: refreshToken
            }
        }

        let { resource } = this.vals
        if (!resource) {
            resource = (await this.get({ lock: false })).resource
            this.vals.resource = resource
        }

        const request = {
            method: 'POST',
            url: `${this.node.mayaBackendUrl}/api/v2/oauth/refresh`,
            data: { 
                resource, 
                access_token, 
                refresh_token,
                moduleId: this.node.modulePackageName,
                runtimeId: this.node._mayaRuntimeId
            },
            headers: {
                ...authHeaders
            },
            timeout: 10000
        }

        try {
            const response = await axios(request)
            this.resetMayaTokenIfRequired(response)

            console.log('Tokens successfully refreshed', response.data)
            const { access_token, refresh_token, resource, referenceId } = response.data
            this.setLocal(response.data, { lock: false, referenceId })

            return { access_token, refresh_token, resource, error: false, referenceId }
        } catch (e) {
            console.log('Error refreshing token in module-sdk')
            if (e.response) {
                console.log('CONFIG', e.config)
                console.log('STATUS', e.response.status)
                console.log('RESPONSE DATA', e.response.data)
            } else {
                console.log(e)
            }

            return {
                access_token: access_token,
                refresh_token: refresh_token,
                resource: null,
                error: true
            }
        }
    }

    async setLocal(token, { lock = true, referenceId = null } = {}) {
        await this.validateHierarchy(this.hierarchy)

        if (!token.access_token || !token.lastUpdated) {
            throw new Error('Missing fields on token: must have access_token and lastUpdated')
        }

        const runtimeBlock = this.db.collection('tokens/runtimeMappings').block(this.node._mayaRuntimeId)
        const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)

        const getFunc = lock ? 'lockAndGet' : 'get'
        const setFunc = lock ? 'lockAndSet' : 'set'

        // If referenceId is not specified
        // Try getting referenceId from vals if set earlier
        if (referenceId === null) {
            referenceId = this.vals.referenceId
        }

        // Otherwise, try getting it from the local db cache
        if (!referenceId) {
            const profileResult = await runtimeBlock[getFunc]({
                [this.node.modulePackageName]: null
            })
    
            console.log('profileResult', profileResult)
    
            referenceId = profileResult[this.node.modulePackageName]
            if (!referenceId || typeof referenceId !== 'string') {
                throw new Error('Invalid result while fetching token:', referenceId)
            }
        }


        await tokenBlock[setFunc]({
            profiles: {
                [referenceId]: token
            }
        })

        this.vals = token
    }

    async set(token, { lock = true } = {}) {
        let authHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            authHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken, refreshToken } = await this.getMayaBackendToken()
            authHeaders = {
                Authorization: `Bearer ${accessToken}`,
                maya_refresh_token: refreshToken
            }   
        }

        const request = {
            method: 'POST',
            url: `${this.node.mayaBackendUrl}/api/v2/oauth/settokens`,
            headers: {
                ...authHeaders
            },
            data: {
                runtimeId: this.node._mayaRuntimeId,
                moduleId: this.node.modulePackageName,
                lock: lock,
                tokens: token
            }
        }

        const response = await axios(request)
        
        this.resetMayaTokenIfRequired(response)
        const { referenceId } = response.data

        await this.setLocal(token, { lock, referenceId })
        return { referenceId }
    }

    resetMayaTokenIfRequired(response) {
        if (!response || process.env.RUNTIME_PLATFORM === 'CLOUD') return
        const { maya_access_token, maya_refresh_token } = response.headers
        if (maya_access_token !== this.mayaJWT) {
            this.mayaJWT = maya_access_token
            this.mayaJWTLastRefreshed = Date.now()
        }
    }

    async lockTokens(callback) {
        let localToks
        try {
            localToks = this.getLocal({ lock: false })
        } catch (e) {
            console.log('No backup token vals found')
        }

        let authHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            authHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken, refreshToken } = await this.getMayaBackendToken()
            authHeaders = {
                Authorization: `Bearer ${accessToken}`,
                maya_refresh_token: refreshToken
            }   
        }

        const lockRequest = {
            method: 'POST',
            url: `${this.node.mayaBackendUrl}/api/v2/oauth/gettokens`,
            headers: {
                ...authHeaders
            },
            data: {
                runtimeId: this.node._mayaRuntimeId,
                moduleId: this.node.modulePackageName,
                lock: true,
                leaveLock: true,
                strict: false,
                backupTokVals: localToks
            }
        }
        
        const res = await axios(lockRequest)
        this.resetMayaTokenIfRequired(res)

        const { lockId, tokens, referenceId } = res.data

        let newAuthHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            newAuthHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken: nat, refreshToken: nrt } = await this.getMayaBackendToken()
            newAuthHeaders = {
                Authorization: `Bearer ${nat}`,
                maya_refresh_token: nrt
            }
        }
        const unlockRequest = {
            method: 'POST',
            url: `${this.node.mayaBackendUrl}/api/v2/oauth/unlocktokens`,
            headers: {
                ...newAuthHeaders
            },
            data: {
                moduleId: this.node.modulePackageName,
                lockId: lockId
            }
        }

        // Not waiting for unlock because it's a non-critical operation
        axios(unlockRequest)
        return await callback({ ...tokens, referenceId })
    }
}

module.exports = Tokens