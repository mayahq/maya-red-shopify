const { localDb, httpAdapter } = require("@mayahq/maya-db");
const path = require('path')
const axios = require('axios');
const getAxiosInstance = require("./axios");

const SECOND = 1000
const MINUTE = 60 * SECOND
const MAYA_DEV_FOLDER = '.mayadev'

class Tokens {
    constructor(node) {
        this.node = node
        this.db = localDb({
            root: path.join(node.mayaRoot, 'db'),
            encryptionKey: node.masterKey
        })

        this.profileSlug = node.profileSlug
        this.dbApiUrl = `${node.mayaBackendUrl}/api/v2/mayadb/db-operation`

        this.mayaJWT = null
        this.mayaJWTLastRefreshed = null
        const encryptionType = (process.env.NODE_ENV === 'development' || process.env.RUNTIME_PLATFORM === 'CLOUD') ? 'BLOCK' : 'ENCRYPTED_BLOCK'

        this.hierarchy = {
            tokens: [{
                modules: [{
                    [node.modulePackageName]: encryptionType
                }],
                runtimeMappings: [{
                    [node._mayaRuntimeId]: encryptionType
                }],
                mayaTokens: [{
                    JWT: encryptionType
                }]
            }]
        }

        if (!node.mayaRoot.includes(MAYA_DEV_FOLDER)) {
            this.db.ensureHierarchy(this.hierarchy)
        }

        this.axiosInstance = getAxiosInstance(
            this.db,
            (token) => this.mayaJWT = token
        )

        this.vals = {
            access_token: null,
            refresh_token: null,
            lastUpdated: null,
            resource: null
        }
    }

    async validateHierarchy() {
        this.db.ensureHierarchy(this.hierarchy)
    }


    /**
     * 
     * @param {Function} callback 
     * @returns {import('./types/tokens').TokenResponse}
     */
    async lockLocalTokens(callback) {
        const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)
        await this.validateHierarchy(this.hierarchy)
        const result = await tokenBlock.acquireLock(async () => {
            const localToks = await this.getLocal({ lock: false })
            if (localToks === null) {
                return await callback({
                    referenceId: '',
                    lastUpdated: -1,
                    tokens: {
                        access_token: null,
                        refresh_token: null,
                        lastUpdated: null
                    }
                })
            }
            return await callback(localToks)
        })

        return result
    }

    /**
     * 
     * @param {*} param0 
     * @returns {import('./types/tokens').TokenResponse}
     */
    async getLocal({ lock = true, referenceId = null } = {}) {
        try {
            await this.validateHierarchy(this.hierarchy)

            const runtimeBlock = this.db.collection('tokens/runtimeMappings').block(this.node._mayaRuntimeId)
            const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)
            
            const getFunc = lock ? 'lockAndGet' : 'get'
            
            // Try getting referenceId from vals if it was set earlier
            if (referenceId === null) {
                referenceId = this.referenceId
            }

            // Otherwise try getting it from the local store
            if (!referenceId) {
                const profileResult = await runtimeBlock[getFunc]({
                    [this.node.modulePackageName]: null
                })

                referenceId = profileResult[this.node.modulePackageName]
                if (!referenceId || typeof referenceId !== 'string') {
                    console.log('getLocal :: no referenceId found ::', referenceId)
                    return null
                }
            }

            const tokFileResult = await tokenBlock[getFunc]({
                profiles: {
                    [referenceId]: null
                }
            })

            return tokFileResult.profiles[referenceId]
        } catch (e) {
            console.log('Error getting local tokens', e)
            return null
        }
    }

    /**
     * 
     * @param {*} param0 
     * @returns {Promise<import('./types/tokens').TokenResponse>}
     */
    async get({ lock = true, cacheLimit = 45 * MINUTE } = {}) {
        console.log('get called')
        try {
            await this.validateHierarchy(this.hierarchy)
            const localToks = await this.getLocal({ lock })
            if (localToks !== null && Date.now() - localToks.lastUpdated < cacheLimit) {
                console.log(`Get: cache hit. Tokens were ${(Date.now() - localToks.lastUpdated)/(60*1000)} minutes old`)
                return localToks
            }

            // Constructing request for getting tokens
            let authHeaders = {}
            if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
                authHeaders = {
                    'maya-api-key': await this.getApiKey()
                }
            } else {
                const { accessToken, refreshToken } = await this.getMayaBackendToken()
                authHeaders = {
                    Authorization: `Bearer ${accessToken}`,
                    maya_refresh_token: refreshToken
                }
            }

            const request = {
                method: 'GET',
                url: `${this.node.mayaBackendUrl}/api/v2/tokens`,
                headers: {
                    ...authHeaders,
                    profileslug: this.profileSlug
                },
                data: {
                    workspaceId: this.node._mayaRuntimeId,
                    modulePackageName: this.node.modulePackageName,
                    lock: lock,
                }
            }

            // Actually making the token-get request.
            console.log('Making token get request', request)
            const res = await this.axiosInstance(request)

            /**
             * @type {import('./types/tokens').TokenApiResponse}
             */
            const { results: tokenData } = res.data
            
            console.log('got gettokens response', tokenData)
            const { tokens, referenceId, lastUpdated } = tokenData

            // Setting tokens to local cache.
            // This is a best-effort operation, we don't care if it fails.
            try {
                await this.setLocal(tokenData, { lock })
                console.log('Saved to local cache', lock, referenceId)
            } catch (e) {
                console.log('Get: Failed to set tokens in local cache:', e)
            }

            this.referenceId = referenceId
            this.resource = tokenData.resource
            this.vals = tokenData.tokens
            this.lastUpdated = tokenData.lastUpdated
            return tokenData

        } catch (e) {
            console.log('error whoops', e)
            console.log('Error fetching tokens', e.response.data)
            return null
        }
    }

    async getMayaBackendToken() {
        await this.validateHierarchy(this.hierarchy)

        const jwtBlock = this.db.block('tokens/mayaTokens/JWT')
        const { JWT, accessToken, refreshToken } = await jwtBlock.lockAndGet({
            JWT: null,
            accessToken: null,
            refreshToken: null
        })

        this.mayaJWT = JWT || accessToken
        this.mayaJWTLastRefreshed = Date.now() // Just setting this to make things easier to reason about

        return { 
            accessToken,
            refreshToken 
        }
    }

    async getApiKey() {
        return process.env.MAYA_API_KEY
    }

    /**
     * 
     * @param {{ access_token: string, refresh_token: string }} tokens 
     * @returns {Promise<import('./types/tokens').TokenResponse>} 
     */
    async refresh({ access_token, refresh_token }) {
        // Constructing the refresh request
        let authHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            authHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken, refreshToken } = await this.getMayaBackendToken()
            authHeaders = {
                Authorization: `Bearer ${accessToken}`,
                maya_refresh_token: refreshToken
            }
        }

        // Either get resource from memory or get it from the API
        let resource = this.resource
        if (!resource) {
            const ret = await this.get({ lock: false })
            resource = ret.resource
            this.resource = resource
        }

        // Construct refresh request body
        const request = {
            method: 'POST',
            url: `${this.node.mayaBackendUrl}/api/v2/oauth/refresh`,
            data: { 
                resource, 
                access_token, 
                refresh_token,
                moduleId: this.node.modulePackageName,
                runtimeId: this.node._mayaRuntimeId
            },
            headers: {
                ...authHeaders,
                profileslug: this.profileSlug
            },
            timeout: 10000
        }

        // Actually make the request
        try {
            const response = await this.axiosInstance(request)
            /**
             * @type {import('./types/tokens').TokenApiResponse}
             */
            const { results: tokenData } = response.data

            console.log('Tokens successfully refreshed', response.data)

            try {
                this.setLocal(tokenData, { lock: false })
            } catch (e) {
                console.log('Failed setting tokens to cache. Moving on.', e)
            }

            return tokenData
        } catch (e) {
            console.log('Error refreshing token in module-sdk')
            if (e.response) {
                console.log('CONFIG', e.config)
                console.log('STATUS', e.response.status)
                console.log('RESPONSE DATA', e.response.data)
            } else {
                console.log(e)
            }

            /**
             * @type {import('./types/tokens').TokenResponse}
             */
            return {
                referenceId: this.referenceId,
                resource: resource,
                tokens: {
                    access_token: access_token,
                    refresh_token: refresh_token,
                },
                error: true,
                lastUpdated: this.vals ? this.vals.tokens : -1
            }
        }
    }

    /**
     * 
     * @param {import('./types/tokens').TokenResponse} tokenData 
     * @param {{ lock: boolean }} options 
     */
    async setLocal(tokenData, { lock = true } = {}) {
        // console.log('setLocal called', referenceId, token)
        await this.validateHierarchy(this.hierarchy)
        const { tokens, referenceId, lastUpdated } = tokenData

        if (!tokens.access_token || !lastUpdated) {
            throw new Error('Missing fields: must have access_token and lastUpdated')
        }

        const runtimeBlock = this.db.collection('tokens/runtimeMappings').block(this.node._mayaRuntimeId)
        const tokenBlock = this.db.collection('tokens/modules').block(this.node.modulePackageName)
        const setFunc = lock ? 'lockAndSet' : 'set'

        try {
            await runtimeBlock[setFunc]({
                [this.node.modulePackageName]: referenceId
            })
        } catch (e) {
            throw new Error('Failed to set referenceId in runtimeMap in local token cache')
        }

        await tokenBlock[setFunc]({
            profiles: {
                [referenceId]: tokenData
            }
        })

        this.vals = tokenData.tokens
        this.lastUpdated = tokenData.lastUpdated
    }

    /**
     * 
     * @param {import('./types/tokens').Tokens} token 
     * @param {{ lock: boolean }} options 
     * @returns 
     */
    async set(token, { lock = true } = {}) {
        // Constructing the request body for setting tokens
        let authHeaders = {}
        if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
            authHeaders = {
                'maya-api-key': await this.getApiKey()
            }
        } else {
            const { accessToken, refreshToken } = await this.getMayaBackendToken()
            authHeaders = {
                Authorization: `Bearer ${accessToken}`,
                maya_refresh_token: refreshToken
            }   
        }

        const request = {
            method: 'PUT',
            url: `${this.node.mayaBackendUrl}/api/v2/tokens`,
            headers: {
                ...authHeaders,
                profileslug: this.profileSlug
            },
            data: {
                workspaceId: this.node._mayaRuntimeId,
                modulePackageName: this.node.modulePackageName,
                lock: lock,
                tokens: token
            }
        }

        // Actually making the request
        const response = await this.axiosInstance(request)
        
        /**
         * @type {import('./types/tokens').TokenApiResponse}
         */
        const { results: tokenData } = response.data
        this.vals = tokenData.tokens
        this.lastUpdated = tokenData.lastUpdated
        const { referenceId } = tokenData

        try {
            await this.setLocal(tokenData, { lock })
        } catch (e) {
            console.log('token set :: failed to set tokens in cache ::', e)
        }
        return { referenceId }
    }

    lockTokens(callback) {
        return new Promise(async (resolve, reject) => {
            let authHeaders = {}
            if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
                authHeaders = {
                    'maya-api-key': await this.getApiKey()
                }
            } else {
                const { accessToken, refreshToken } = await this.getMayaBackendToken()
                authHeaders = {
                    Authorization: `Bearer ${accessToken}`,
                    maya_refresh_token: refreshToken
                }   
            }
    
            const lockRequest = {
                method: 'POST',
                url: `${this.node.mayaBackendUrl}/api/v2/tokens/lock`,
                headers: {
                    ...authHeaders,
                    profileslug: this.profileSlug
                },
                data: {
                    workspaceId: this.node._mayaRuntimeId,
                    modulePackageName: this.node.modulePackageName,
                    duration: 60000,
                    timeout: 30000,
                }
            }
            
            const res = await this.axiosInstance(lockRequest)
    
            /**
             * @type {import('./types/tokens').TokenLockApiResponse}
             */
            const { results }  = res.data
            const { tokenData, lockId } = results
    
            let newAuthHeaders = {}
            if (process.env.RUNTIME_PLATFORM === 'CLOUD') {
                newAuthHeaders = {
                    'maya-api-key': await this.getApiKey()
                }
            } else {
                const { accessToken: nat, refreshToken: nrt } = await this.getMayaBackendToken()
                newAuthHeaders = {
                    Authorization: `Bearer ${nat}`,
                    maya_refresh_token: nrt
                }
            }
    
            const unlockRequest = {
                method: 'POST',
                url: `${this.node.mayaBackendUrl}/api/v2/tokens/unlock`,
                headers: {
                    ...newAuthHeaders,
                    profileslug: this.profileSlug
                },
                data: {
                    modulePackageName: this.node.modulePackageName,
                    workspaceId: this.node._mayaRuntimeId,
                    lockId: lockId
                }
            }
    
            try{
                const res = await callback(tokenData)
                resolve(res)
            } catch (e) {
                console.log('Token lock callback failed:', e)
            } 
            // Not waiting for unlock because it's a non-critical operation
            this.axiosInstance(unlockRequest)
        })
    }
}

module.exports = Tokens