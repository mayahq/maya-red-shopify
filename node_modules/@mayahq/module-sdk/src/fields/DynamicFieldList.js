const Field = require('../field')
const dedent = require('dedent-js')

class DynamicFieldList extends Field {
    constructor({
        rowFields = {},
        displayName = null,
        defaultSet = [],
        forConfig = false,
        isCredential = false
    }) {
        super(arguments[0])

        this.rowFields = rowFields

        if (defaultSet) {
            this.defaultSet = defaultSet
        } else {
            const fieldSetNames = Object.keys(rowFields)
            if (fieldSetNames.length > 0) {
                this.defaultSet = fieldSetNames[0]
            } else {
                this.defaultSet = ''
            }
        }

        this.childFields = {}
        this.childFieldNames = []
        
        Object.entries(this.rowFields).forEach(([fieldName, field]) => {
            field.forConfig = this.forConfig
            field.isConfigNodeField = this.isConfigNodeField
            field.isCredential = this.isCredential
            this.childFields[fieldName] = field
            this.childFieldNames.push(fieldName)
        })
    } 

    resolveValue(RED, name, node, config, msg) {
        const allRows = []
        const dynamicList = config[name]
        try {
            dynamicList.forEach((row) => {
                const vals = {}
                Object.entries(row).forEach(([fieldName, field]) => {
                    if(this.childFields[fieldName]?.isSdkType){
                        if(this.childFields[fieldName]?.kind === "typed"){
                            vals[fieldName] = RED.util.evaluateNodeProperty(row[fieldName], row[`payloadType${fieldName}`], node, msg)
                        } else {
                            vals[fieldName] = field
                        }
                    } else if (fieldName.startsWith("payloadType")) {
                        console.log("Ignoring type entries")
                    }
                    else {
                        vals[fieldName] = field
                    }
                })
                allRows.push(vals)
            })
        } catch (e) {
            throw new Error(`${e}`)
        }
        return allRows
    }

    registerWithNode(name, node, config) {
        node[name] = config[name]
    }

    defaultsCode(name, schema) {
        if (this.isCredential) {
            return ''
        }

        const childFieldDefaults = {}
        
        Object.entries(this.childFields).forEach(([fieldName, field]) => {
            if(field.kind === "typed"){
                // TODO when SDK types can be included in editable list
                // throw new Error("Unsupported types");
                childFieldDefaults[fieldName] = ""
                childFieldDefaults["payloadType"+fieldName] = ""
            } else {
                childFieldDefaults[fieldName] = ""
            }
        })

        return dedent(`
            ${name}: { value: [${JSON.stringify(childFieldDefaults)}], required: true },
        `)

    }

    credentialsCode(name, schema) {
        if (!this.isCredential) {
            return ''
        }

        const childFieldCode = []
        Object.entries(this.childFields).forEach(([fieldName, field]) => {
            childFieldCode.push(
                field.credentialsCode(fieldName, schema)
            )
        })

        return dedent(`
            ${childFieldCode.join('\n')}
            ${name}: { type: String },
        `)
    }


    onEditPrepareCode(name, schema) {
        const childFieldCode = []
        const childFieldNames = []
        Object.entries(this.childFields).forEach(([fieldName, field]) => {
            if(field.isSdkType){
                switch(field.kind) {
                    case "typed":{
                        const prefix = schema.isConfig ? 'node-config-input' : 'node-input'                        
                        childFieldCode.push(dedent(`
                        $("<input/>", {
                            class: "${prefix}-option-${fieldName}",
                            value: option.${fieldName},
                        }).appendTo(row).typedInput({
                            default: "${field.type}",
                            types: ${JSON.stringify(field.allowedTypes)},
                            typeField: "${prefix}-option-payloadType${fieldName}"
                        }).typedInput('type', option.payloadType${fieldName})
                        `))
                        break;
                    }
                    case "select":{
                        const prefix = schema.isConfig ? 'node-config-input' : 'node-input'
                        childFieldCode.push(
                            dedent(
                        `
                            let ${fieldName} = $("<select/>", {
                                class: "${prefix}-option-${fieldName}"
                            })
                            const ${fieldName}selectFieldValues = ${JSON.stringify(field.options)}
                            ${fieldName}selectFieldValues.forEach((val) => {
                                option.${fieldName} === val ? ${fieldName}.append($("<option></option>").attr("value", val).attr("selected", "selected").text(val)) : ${fieldName}.append($("<option></option>").attr("value", val).text(val))
                            })
                            ${fieldName}.val(option.${fieldName})
                            ${fieldName}.appendTo(row)
                        `))
                        break;
                    }
                    default:{
                        throw new Error("This field type is not supported in Dynamic List")
                    }
                }
            } else {
                // https://www.w3schools.com/html/html_form_input_types.asp

                if(field.type !== "custom"){
                    childFieldCode.push(
                        dedent(`
                        $("<input/>", {
                            class: "node-input-option-${fieldName}",
                            type: "${field.type || "text"}",
                            style: "margin-left:7px; width:30%;",
                            placeholder: "${fieldName}",
                            value: option.${fieldName},
                            required: ${field.required === false || field.required === undefined ? false : true}
                        }).appendTo(row);
                        `)
                    )
                } else {
                    childFieldCode.push(
                        dedent(`
                        let ${fieldName} = $('${field.html}')
                        ${fieldName}.addClass("node-input-option-${fieldName}")
                        ${fieldName}.appendTo(row);
                        `)
                    )
                }
                
            }
            childFieldNames.push(fieldName)
        })
        return dedent(`

            function generateOption(i, option) {
                var container = $("<li/>", {
                    style:
                        "margin:0; padding:8px 0px 0px; border-bottom:1px solid #ccc;",
                });
                var row = $("<div/>").appendTo(container);

                $(
                    '<i style="cursor:move; margin-left:3px;" class="node-input-option-handle fa fa-bars"></i>'
                ).appendTo(row);

                ${
                    childFieldCode.join("\n\n")
                }

                var finalspan = $("<div/>", {
                    style: "display:inline-block; width:5%;",
                }).appendTo(row);
                var deleteButton = $("<a/>", {
                    href: "#",
                    class: "editor-button",
                    style: "font-size:1.3em; left:45%; position:relative;",
                }).appendTo(finalspan);
                $("<i/>", { class: "fa fa-trash-o" }).appendTo(deleteButton);

                deleteButton.click(function () {
                    ${
                        childFieldNames.map(cf => {
                            return `container.find(".node-input-option-${cf}").removeAttr("required");`
                        }).join("\n")
                    }
                    container.css({ background: "#fee" });
                    container.fadeOut(100, function () {
                        $(this).remove();
                    });
                });

                $("#node-input-option-container").append(container);
            }

            $("#node-input-add-option").click(function () {
                generateOption(
                    $("#node-input-option-container").children().length + 1,
                    {}
                );
                $("#node-input-option-container-div").scrollTop(
                    $("#node-input-option-container-div").get(0).scrollHeight);
            });

            for (var i = 0; i < this.${name}.length; i++) {
                var option = this.${name}[i];
                generateOption(i + 1, option);
            }

            $("#node-input-option-container").sortable({
                axis: "y",
                handle: ".node-input-option-handle",
                cursor: "move",
            });
            
            `)
    }


    formCode(name, schema) {
        // const fieldSetCodes = []
        const prefix = schema.isConfig ? 'node-config-input' : 'node-input'
        // Object.entries(this.rowFields).forEach(([fieldSetName, fieldSet]) => {
        //     const childFieldCodes = []
        //     Object.entries(fieldSet).forEach(([fieldName, field]) => {
        //         childFieldCodes.push(field.formCode(fieldName, schema))
        //     })
        //     fieldSetCodes.push(dedent(`
        //         <div id="fieldset-${fieldSetName}" style="padding-left: 10px;">
        //             ${childFieldCodes.join('\n')}
        //         </div>
        //     `))
        // })

        return dedent(`
            <div class="form-row node-input-option-container-row" style="margin-bottom:0px; width:100%; min-width:520px">
                <label style="vertical-align:top;"><i class="fa fa-list-alt"></i> ${this.displayName ? this.displayName : name}</label>
                <div style="display:inline-block; width:78%; border:1px solid #ccc; border-radius:5px; box-sizing:border-box;">
                <div id="node-input-option-container-div" style=" height: 257px; padding: 5px; overflow-y:scroll;">
                    <ol id="node-input-option-container" style=" list-style-type:none; margin: 0;"></ol>
                </div>
                </div>
            </div>
            <div class="form-row">
                <a href="#" class="editor-button editor-button-small" id="node-input-add-option" style="margin-top: 4px; margin-left: 103px;"><i class="fa fa-plus"></i> <span>element</span></a>
            </div>
            <div class="form-row">
        `)
    }

    onEditSaveCode(name, schema) {
        // const childFieldNames = []
        // const childFieldCode = []
        // Object.entries(this.childFields).forEach(([fieldName, field]) => {
        //     childFieldCode.push(
        //         field.onEditPrepareCode(fieldName, schema)
        //     )
        //     childFieldNames.push(fieldName)
        // })

        return dedent(`
        var ${name} = $("#node-input-option-container").children();
        var node = this;
        node.${name} = [];
        ${name}.each(function (i) {
            var option = $(this);
            var o = {
                ${
                    Object.entries(this.childFields).map(([fieldName, field]) => {
                        if(field.isSdkType){
                            if(field.kind === "typed"){
                                return `payloadType${fieldName}: option.children().children(".node-input-option-${fieldName}").typedInput('type'),
                                ${fieldName}: option.children().children(".node-input-option-${fieldName}").typedInput('value'),`
                            }
                            if(field.kind === "select"){
                                return `${fieldName}: option.children().children(".node-input-option-${fieldName}").find(":selected").val(),`
                            }
                        } else {
                            return `${fieldName}: option.children().children(".node-input-option-${fieldName}").val(),`
                        }
                    }).join("\n")

                    // this.childFieldNames.map(cf => {
                    //     return `${cf}: option.find(".node-input-option-${cf}").val(),`
                    // }).join("\n")
                }
            };
            node.${name}.push(o);
        })
        `)
    }

    // onEditCancelCode(name, schema) {
    //     return dedent(``)
    // }

    // onEditDeleteCode(name, schema) {
    //     return dedent(``)
    // }

    // onEditResizeCode(name, schema) {
    //     const childFieldCode = []
    //     Object.entries(this.childFields).forEach(([fieldName, field]) => {
    //         childFieldCode.push(
    //             field.onEditResizeCode(fieldName, schema)
    //         )
    //     })

    //     return dedent(`${childFieldCode.join('\n')}`)
    // }

    // onPaletteAddCode(name, schema) {
    //     const childFieldCode = []
    //     Object.entries(this.childFields).forEach(([fieldName, field]) => {
    //         childFieldCode.push(
    //             field.onPaletteAddCode(fieldName, schema)
    //         )
    //     })

    //     return dedent(`${childFieldCode.join('\n')}`)
    // }

    // onPaletteRemoveCode(name, schema) {
    //     const childFieldCode = []
    //     Object.entries(this.childFields).forEach(([fieldName, field]) => {
    //         childFieldCode.push(
    //             field.onPaletteRemoveCode(fieldName, schema)
    //         )
    //     })

    //     return dedent(`${childFieldCode.join('\n')}`)
    // }
    
}

module.exports = DynamicFieldList